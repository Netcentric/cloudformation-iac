AWSTemplateFormatVersion: "2010-09-09"
Description: "CloudFormation IaC --- EC2 Instance with optional Route 53 DNS Records. The template contains Cloud-Init code that will pre-install AWS-CLI Tools, CFN-Bootstrap, CFN-Hup and the Puppet Agent together with some service scripts for additional functionality (triggered after creation)."

################################################################################
#
# Decision Trees:
#
#   DNS entries:
#     HostedZoneName != ""
#       true  -> Created
#       false -> None [default]
#
#   EBS Volumes:
#     <VOL>VolumeSize != 0
#       true  -> Created
#       false -> None [default]
#
################################################################################


################################################################################
#
# Metadata (optional)
# provide details about the template
#
# See: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html
#
################################################################################

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: "Naming details"
      Parameters:
      - Designation
      - RootStackName
    - Label:
        default: "Instance configuration"
      Parameters:
      - AvailabilityZone
      - HostName
      - IamInstanceProfile
      - IamManagedPolicies
      - ImageId
      - InstanceType
      - RootKeyName
      - SecurityGroupIds
      - SubnetId
    - Label:
        default: "Additional features"
      Parameters:
      - FeatureAutoSnapshot
      - FeatureUptimeWindows
    - Label:
        default: "/ (optional)"
      Parameters:
      - RootDeviceName
      - RootDeviceEncryption
      - RootDeviceIops
      - RootDeviceSize
      - RootDeviceType
    - Label:
        default: "/opt (optional)"
      Parameters:
      - VolumeOptDeviceName
      - VolumeOptEncryption
      - VolumeOptIops
      - VolumeOptSize
      - VolumeOptThroughput
      - VolumeOptType
    - Label:
        default: "/tmp (optional)"
      Parameters:
      - VolumeTmpDeviceName
      - VolumeTmpEncryption
      - VolumeTmpIops
      - VolumeTmpSize
      - VolumeTmpThroughput
      - VolumeTmpType
    - Label:
        default: "/var (optional)"
      Parameters:
      - VolumeVarDeviceName
      - VolumeVarEncryption
      - VolumeVarIops
      - VolumeVarSize
      - VolumeVarThroughput
      - VolumeVarType
    - Label:
        default: "DNS Record configuration (optional)"
      Parameters:
      - DnsServiceToken
      - HostedZoneName


################################################################################
#
# Parameters (optional)
# Passes values into templates when creating a stack
#
# See: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html
#
################################################################################

Parameters:
  #=======================================
  # Naming details
  #=======================================

  Designation:
    Description: "A string used to tell the resources created by different instances of this stack apart (for example its purpose or just a number)."
    Type: String

  RootStackName:
    Description: "The name of the top-level Stack this Stack, if nested, ultimately belongs to (this Stacks name else; examples: \"assets-dev\" or \"sites-prod\")."
    Type: String

  #=======================================
  # Instance configuration
  #=======================================

  AvailabilityZone:
    Description: "The Availability Zone in which the Instance and its Volumes will be placed."
    Type: AWS::EC2::AvailabilityZone::Name

  HostName:
    Description: "The name that will be used for this host and, if created, its DNS name (example: \"sites-dev1-author-1\"; default: \"${RootStackName}-${Designation}\")."
    Type: String
    Default: ""

  IamInstanceProfile:
    Description: "The ARN of an IAM Instance Profile that is used to grant permissions to this EC2 Instance (takes precedence over IamManagedPolicies)."
    Type: String
    Default: ""

  IamManagedPolicies:
    Description: "The ARNs of IAM Managed Policies that are used to grant permissions to this EC2 Instance (will be used to create an Instance Profile, if IamInstanceProfile has not been specified)."
    Type: CommaDelimitedList
    Default: ""

  ImageId:
    Description: "The unique ID of the Amazon Machine Image (AMI) the Instance will be created from."
    Type: AWS::EC2::Image::Id

  InstanceType:
    Description: "The instance type (examples: \"t3a.micro\" or \"m5.xlarge\")."
    Type: String

  RootKeyName:
    Description: "The name of the Amazon EC2 key pair that will be used to access the Instance via SSH."
    Type: AWS::EC2::KeyPair::KeyName

  SecurityGroupIds:
    Description: "A list that contains the IDs for VPC Security Groups to assign to the Instance."
    Type: CommaDelimitedList

  SubnetId:
    Description: "The ID of the Subnet the Instance will be launched into."
    Type: AWS::EC2::Subnet::Id

  #=======================================
  # Additional features
  #=======================================

  FeatureAutoSnapshot:
    Description: "Whether EBS Volumes should be backed up automatically not. This feature can be enabled by specifying a ScheduleName that was used with the \"automatic-snapshots\" template (examples: \"Daily\")."
    Type: String
    Default: "disabled"

  FeatureUptimeWindows:
    Description: "A list consisting of two elements in the UNIX cron format, the first representing the start and the second the stop times. If set to \"disabled\", the instances will run 24/7 (example: \"* 4 ? * MON-FRI *\", \"* 20 ? * MON-FRI *\")."
    Type: CommaDelimitedList
    Default: "disabled"

  #=======================================
  # / (optional)
  #=======================================

  RootDeviceName:
    Description: "The device name set by the AMI (example: \"/dev/sda1\")."
    Type: String
    Default: ""

  RootDeviceEncryption:
    Description: "Whether this Volumes should be encrypted or not."
    Type: String
    AllowedValues: [ "", "false", "true" ]
    Default: ""

  RootDeviceIops:
    Description: "The number of I/O operations per second (IOPS)."
    Type: Number
    Default: 0

  RootDeviceSize:
    Description: "The size of the Volume, in gibibytes."
    Type: Number
    Default: 0

  RootDeviceType:
    Description: "The Volume type."
    Type: String
    AllowedValues: [ "", "standard", "io1", "io2", "gp2", "gp3", "sc1", "st1" ]
    Default: ""

  #=======================================
  # /opt (optional)
  #=======================================

  VolumeOptDeviceName:
    Description: "How the device will be exposed to the Instance (examples: \"/dev/sdh\" or \"xvdf\")."
    Type: String
    Default: "xvdf"

  VolumeOptEncryption:
    Description: "Whether this Volumes should be encrypted or not."
    Type: String
    AllowedValues: [ "false", "true" ]
    Default: "false"

  VolumeOptIops:
    Description: "The number of I/O operations per second (IOPs) that the Volume will support (only used if VolumeOptType is set to \"io1\", \"io2\" or \"gp3\")."
    Type: Number
    Default: 0

  VolumeOptSize:
    Description: "The size of the Volume, in gibibytes (if this value is 0 the volume will not be created)."
    Type: Number
    Default: 0

  VolumeOptThroughput:
    Description: "The throughput of the Volume, in MiB/s (only used if VolumeOptType is set to \"gp3\")."
    Type: Number
    Default: 125

  VolumeOptType:
    Description: "The Volume type (if you set the type to \"io1\" or \"io2\", you must also set the VolumeOptIops property)."
    Type: String
    AllowedValues: [ "standard", "io1", "io2", "gp2", "gp3", "sc1", "st1" ]
    Default: "gp3"

  #=======================================
  # /tmp (optional)
  #=======================================

  VolumeTmpDeviceName:
    Description: "How the device will be exposed to the Instance (examples: \"/dev/sdh\" or \"xvdf\")."
    Type: String
    Default: "xvdg"

  VolumeTmpEncryption:
    Description: "Whether this Volumes should be encrypted or not."
    Type: String
    AllowedValues: [ "false", "true" ]
    Default: "false"

  VolumeTmpIops:
    Description: "The number of I/O operations per second (IOPS) that the Volume will support (only used if VolumeTmpType is set to \"io1\", \"io2\" or \"gp3\")."
    Type: Number
    Default: 0

  VolumeTmpSize:
    Description: "The size of the Volume, in gibibytes (if this value is 0 the volume will not be created)."
    Type: Number
    Default: 0

  VolumeTmpThroughput:
    Description: "The throughput of the Volume, in MiB/s (only used if VolumeTmpType is set to \"gp3\")."
    Type: Number
    Default: 125

  VolumeTmpType:
    Description: "The volume type (if you set the type to \"io1\" or \"io2\", you must also set the VolumeTmpIops property)."
    Type: String
    AllowedValues: [ "standard", "io1", "io2", "gp2", "gp3", "sc1", "st1" ]
    Default: "gp3"

  #=======================================
  # /var (optional)
  #=======================================

  VolumeVarDeviceName:
    Description: "How the device will be exposed to the Instance (examples: \"/dev/sdh\" or \"xvdf\")."
    Type: String
    Default: "xvdh"

  VolumeVarEncryption:
    Description: "Whether this Volumes should be encrypted or not."
    Type: String
    AllowedValues: [ "false", "true" ]
    Default: "false"

  VolumeVarIops:
    Description: "The number of I/O operations per second (IOPS) that the Volume will support (only used if VolumeVarType is set to \"io1\", \"io2\" or \"gp3\")."
    Type: Number
    Default: 0

  VolumeVarSize:
    Description: "The size of the Volume, in gibibytes (if this value is 0 the volume will not be created)."
    Type: Number
    Default: 0

  VolumeVarThroughput:
    Description: "The throughput of the Volume, in MiB/s (only used if VolumeVarType is set to \"gp3\")."
    Type: Number
    Default: 0

  VolumeVarType:
    Description: "The volume type (if you set the type to \"io1\" or \"io2\", you must also set the VolumeVarIops property)."
    Type: String
    AllowedValues: [ "standard", "io1", "io2", "gp2", "gp3", "sc1", "st1" ]
    Default: "gp3"

  #=======================================
  # DNS Record configuration (optional)
  #=======================================

  DnsServiceToken:
    Description: "The SNS Topic ARN or Lambda function ARN that was provided to access the service that manages remote DNS Records (only required if DNS Records are managed in a different account; must be from the same region as this stack)."
    Type: String
    Default: ""

  HostedZoneName:
    Description: "The name of the domain for the Hosted Zone where the Record Sets should be added (if left empty, no DNS Record will be created; example: \"my-project.example.com\")."
    Type: String
    Default: ""


################################################################################
#
# Conditions (optional)
# Includes statements that define when a resource is created or when a property is defined
#
# See: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/conditions-section-structure.html
#
################################################################################

Conditions:
  #----------------------------
  # Naming
  #----------------------------

  # Whether HostName has been explicitly provided or not
  HasHostName: !Not
    - !Equals [ !Ref HostName, "" ]

  #----------------------------
  # Features
  #----------------------------

  # If the automatic snapshot scheduler is not configured, this feature will be disabled
  EnableAutoSnapshot: !Not
    - !Equals [ !Ref FeatureAutoSnapshot, "disabled" ]

  # If the uptime windows is not configured, this feature will be disabled (the element is a list, so we need to squash it for the comparison)
  EnableUptimeWindows: !Not
    - !Equals
      - !Join [ "", !Ref FeatureUptimeWindows ]
      - "disabled"

  # Whether an IAM Instance Profile has been provided or not
  HasIamInstanceProfile: !Not
    - !Equals [ !Ref IamInstanceProfile, "" ]

  # Whether IAM Managed Policies have been provided or not
  HasIamManagedPolicies: !Not
    - !Equals
      - !Join [ "", !Ref IamManagedPolicies ]
      - ""

  #----------------------------
  # Network
  #----------------------------

  # If no Hosted Zone was given, we won't create a DNS Record
  CreateDnsRecord: !Not
    - !Equals [ !Ref HostedZoneName, "" ]

  #----------------------------
  # Storage
  #----------------------------

  # Configuring the root device only if we have a name and some changed config
  ConfigureRootDevice: !And
    - !Condition HasRootDeviceName
    - !Or
      - !Condition HasRootDeviceEncryption
      - !Condition HasRootDeviceIops
      - !Condition HasRootDeviceSize
      - !Condition HasRootDeviceType

  # If the size is 0, then no separate volume should not be created
  CreateVolumeOpt: !Not
    - !Equals [ !Ref VolumeOptSize, 0 ]

  # If the size is 0, then no separate volume should not be created
  CreateVolumeTmp: !Not
    - !Equals [ !Ref VolumeTmpSize, 0 ]

  # If the size is 0, then no separate volume should not be created
  CreateVolumeVar: !Not
    - !Equals [ !Ref VolumeVarSize, 0 ]

  # Whether a RootDeviceName has been provided or not (allowing us to customize the root device)
  HasRootDeviceName: !Not
    - !Equals [ !Ref RootDeviceName, "" ]

  #  Whether RootDeviceEncryption has been provided or not
  HasRootDeviceEncryption: !Not
    - !Equals [ !Ref RootDeviceEncryption, "" ]

  #  Whether RootDeviceIops has been provided or not
  HasRootDeviceIops: !Not
    - !Equals [ !Ref RootDeviceIops, 0 ]

  #  Whether RootDeviceSize has been provided or not
  HasRootDeviceSize: !Not
    - !Equals [ !Ref RootDeviceSize, 0 ]

  #  Whether RootDeviceType has been provided or not
  HasRootDeviceType: !Not
    - !Equals [ !Ref RootDeviceType, "" ]

  # Whether the I/O performance can and should be set or not
  SetVolumeOptIops: !And
    - !Not
      - !Equals [ !Ref VolumeOptIops, 0 ]
    - !Or
      - !Equals [ !Ref VolumeOptType, "gp3" ]
      - !Equals [ !Ref VolumeOptType, "io1" ]
      - !Equals [ !Ref VolumeOptType, "io2" ]

  # Whether the throughput can and should be set or not
  SetVolumeOptThroughput: !And
    - !Not
      - !Equals [ !Ref VolumeOptThroughput, 0 ]
    - !Equals [ !Ref VolumeOptType, "gp3" ]

  # Whether the I/O performance can and should be set or not
  SetVolumeTmpIops: !And
    - !Not
      - !Equals [ !Ref VolumeTmpIops, 0 ]
    - !Or
      - !Equals [ !Ref VolumeTmpType, "gp3" ]
      - !Equals [ !Ref VolumeTmpType, "io1" ]
      - !Equals [ !Ref VolumeTmpType, "io2" ]

  # Whether the throughput can and should be set or not
  SetVolumeTmpThroughput: !And
    - !Not
      - !Equals [ !Ref VolumeTmpThroughput, 0 ]
    - !Equals [ !Ref VolumeTmpType, "gp3" ]

  # Whether the I/O performance can and should be set or not
  SetVolumeVarIops: !And
    - !Not
      - !Equals [ !Ref VolumeVarIops, 0 ]
    - !Or
      - !Equals [ !Ref VolumeVarType, "gp3" ]
      - !Equals [ !Ref VolumeVarType, "io1" ]
      - !Equals [ !Ref VolumeVarType, "io2" ]

  # Whether the throughput can and should be set or not
  SetVolumeVarThroughput: !And
    - !Not
      - !Equals [ !Ref VolumeVarThroughput, 0 ]
    - !Equals [ !Ref VolumeVarType, "gp3" ]


################################################################################
#
# Resources (required)
# Declares the AWS resources that you want to include in the stack
#
# See: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html
#
################################################################################

Resources:
  #=======================================
  # Instance
  #=======================================

  #----------------------------
  # Instance Profile
  #----------------------------

  InstanceRole:
    Condition: HasIamManagedPolicies
    Type: AWS::IAM::Role
    Properties:
      # Allow the EC2 service to assume this role
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
        Version: "2012-10-17"
      Description: !Sub "Role that defines the privileges of the EC2 Instance \"${RootStackName}-instance-${Designation}\"."
      ManagedPolicyArns: !Ref IamManagedPolicies

  InstanceProfile:
    Condition: HasIamManagedPolicies
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
      - !Ref InstanceRole

  #----------------------------
  # Instance
  #----------------------------

  Instance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: !Ref AvailabilityZone
      BlockDeviceMappings:
      - !If
        - ConfigureRootDevice
        - DeviceName: !Ref RootDeviceName
          Ebs:
            Encrypted: !If
              - HasRootDeviceEncryption
              - !Ref RootDeviceEncryption
              - !Ref AWS::NoValue
            Iops: !If
              - HasRootDeviceIops
              - !Ref RootDeviceIops
              - !Ref AWS::NoValue
            VolumeSize: !If
              - HasRootDeviceSize
              - !Ref RootDeviceSize
              - !Ref AWS::NoValue
            VolumeType: !If
              - HasRootDeviceType
              - !Ref RootDeviceType
              - !Ref AWS::NoValue
        - !Ref AWS::NoValue
      IamInstanceProfile: !If
        - HasIamInstanceProfile
        - !Ref IamInstanceProfile
        - !If
          - HasIamManagedPolicies
          - !Ref InstanceProfile
          - !Ref AWS::NoValue
      ImageId: !Ref ImageId
      InstanceType: !Ref InstanceType
      KeyName: !Ref RootKeyName
      SecurityGroupIds: !Ref SecurityGroupIds
      SubnetId: !Ref SubnetId
      Tags:
      - Key: "Name"
        Value: !Sub "${RootStackName}-instance-${Designation}"
      - !If
        - EnableUptimeWindows
        - Key: "startTime"
          Value: !Select [ "0", !Ref FeatureUptimeWindows ]
        - !Ref AWS::NoValue
      - !If
        - EnableUptimeWindows
        - Key: "stopTime"
          Value: !Select [ "1", !Ref FeatureUptimeWindows ]
        - !Ref AWS::NoValue
      Volumes:
      - !If
        - CreateVolumeOpt
        - Device: !Ref VolumeOptDeviceName
          VolumeId: !Ref VolumeOpt
        - !Ref AWS::NoValue
      - !If
        - CreateVolumeTmp
        - Device: !Ref VolumeTmpDeviceName
          VolumeId: !Ref VolumeTmp
        - !Ref AWS::NoValue
      - !If
        - CreateVolumeVar
        - Device: !Ref VolumeVarDeviceName
          VolumeId: !Ref VolumeVar
        - !Ref AWS::NoValue
      UserData:
        Fn::Base64:
          !Sub |
            #!/usr/bin/env bash

            if [ -f "/etc/os-release" ]; then
              RELEASE_FILE="/etc/os-release"
            else
              RELEASE_FILE="/usr/lib/os-release"
            fi

            OS_ID="$(grep -oP '(?<=^ID=")[ [:alnum:]]*' /etc/os-release)"
            OS_VERSION="$(grep -oP '(?<=^VERSION_ID=")[ [:alnum:]]*' /etc/os-release)"

            # Setup cfn-bootstrap
            case "$OS_ID" in
              'centos'|'rhel')
                case "$OS_VERSION" in
                  '7')
                    ARCHIVE='aws-cfn-bootstrap-latest.tar.gz'
                    EASY_INSTALL='/usr/bin/easy_install'

                    # Install what is required for the bootstrapping
                    yum install --assumeyes jq
                    ;;
                  '8')
                    ARCHIVE='aws-cfn-bootstrap-py3-latest.tar.gz'
                    EASY_INSTALL='/usr/bin/easy_install-3'

                    # Install latest Python 3 (Python 2 went EoL on 2020-01-01)
                    dnf install --assumeyes python3
                    alternatives --set python /usr/bin/python3

                    # Install what is required for the bootstrapping
                    dnf install --assumeyes jq
                    ;;
                  *) exit 1
                esac

                curl "https://s3.amazonaws.com/cloudformation-examples/$ARCHIVE" --output "/tmp/$ARCHIVE"
                $EASY_INSTALL "/tmp/$ARCHIVE"
                ;;
              *) exit 1
            esac

            cfn-init --verbose --stack ${AWS::StackName} --resource Instance --configsets default,init-set,restart-set --region ${AWS::Region}
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          default:
          - SetHostname
          - EnsureAwsCli
          - EnsureCfnHup
          - BootstrapPuppet
          - BootstrapVolumes
          init-set:
          - InitializePuppet
          restart-set:
          - OptionalReboot

        # Install the Puppet Agent and register this node with the Puppet Master
        BootstrapPuppet:
          files:
            # Script to associate this node with an OpsWorks Puppet Master
            # Based on: https://github.com/awsdocs/aws-opsworks-user-guide/blob/master/doc_source/opspup-unattend-assoc.md
            /opt/aws/init/bootstrap-puppet.sh:
              content: |
                #!/usr/bin/env bash

                # ************************************
                # This file is managed by CloudFormation
                # Do not modify!
                # ************************************

                set -euo pipefail

                # PID file to prevent parallel executions of this script
                PID_FILE="/var/run/$(basename $0).pid"

                # Additional optional settings
                AWS_CLI_EXTRA_OPTS=()

                # Override the Instances AWS credentials with the one provided by the node association role for the remote Puppet Master
                function set_remote_credentials {
                  if [ -n "${REMOTE_AWS_ACCESS_KEY_ID-}" ] && [ -n "${REMOTE_AWS_SECRET_ACCESS_KEY-}" ]  && [ -n "${REMOTE_AWS_SESSION_TOKEN-}" ]; then
                    export AWS_ACCESS_KEY_ID=${REMOTE_AWS_ACCESS_KEY_ID}
                    export AWS_SECRET_ACCESS_KEY=${REMOTE_AWS_SECRET_ACCESS_KEY}
                    export AWS_SESSION_TOKEN=${REMOTE_AWS_SESSION_TOKEN}
                  fi
                }

                # Cleanup the credential override so that the ones of the Instance are used again
                function unset_remote_credentials {
                  unset AWS_SESSION_TOKEN
                  unset AWS_ACCESS_KEY_ID
                  unset AWS_SECRET_ACCESS_KEY
                }

                function set_aws_settings {
                  export PP_INSTANCE_ID=$(curl --silent --show-error --retry 3 http://169.254.169.254/latest/meta-data/instance-id)

                  export PP_IMAGE_NAME=$(curl --silent --show-error --retry 3 http://169.254.169.254/latest/meta-data/ami-id)
                  export PP_REGION=$(curl --silent --show-error --retry 3 http://169.254.169.254/latest/meta-data/placement/availability-zone | sed 's/.$//')

                  # Detecting if a tag is set. If so, override anything in the file
                  export OCM_SERVER=$(/usr/local/bin/aws ec2 describe-tags --region ${PP_REGION} --filters "Name=resource-id,Values=${PP_INSTANCE_ID}" --query 'Tags[?Key==`ocm_server`].Value' --output text)
                  export OCM_REGION=$(/usr/local/bin/aws ec2 describe-tags --region ${PP_REGION} --filters "Name=resource-id,Values=${PP_INSTANCE_ID}" --query 'Tags[?Key==`ocm_region`].Value' --output text)
                  export OCM_ROLE=$(/usr/local/bin/aws ec2 describe-tags --region ${PP_REGION} --filters "Name=resource-id,Values=${PP_INSTANCE_ID}" --query 'Tags[?Key==`ocm_role`].Value' --output text)

                  # If no OCM Server is specified, there's nothing to do for us. Clean up and stop
                  if [ -z ${OCM_SERVER} ]; then
                    echo "OCM_SERVER not specified, exiting"
                    rm -f /etc/cron.d/bootstrap-puppet-starter
                    exit 0
                  fi

                  # If the region of the OCM Server is not specified, we'll assume it is in the same region as this Instance
                  if [ -z ${OCM_REGION} ]; then
                    export OCM_REGION=${PP_REGION}
                  fi

                  # If a remote "NodeAssociationRole" has been specified, assume it the to get the credentials required for interacting with the remote Puppet Master
                  if [ ! -z ${OCM_ROLE} ]; then
                    ASSUME_ROLE_OUTPUT=$(/usr/local/bin/aws sts assume-role --role-arn ${OCM_ROLE} --role-session-name "NodeAssociation@${PP_INSTANCE_ID}")
                    export REMOTE_AWS_ACCESS_KEY_ID=$(echo ${ASSUME_ROLE_OUTPUT} | jq .Credentials.AccessKeyId | xargs)
                    export REMOTE_AWS_SECRET_ACCESS_KEY=$(echo ${ASSUME_ROLE_OUTPUT} | jq .Credentials.SecretAccessKey | xargs)
                    export REMOTE_AWS_SESSION_TOKEN=$(echo ${ASSUME_ROLE_OUTPUT} | jq .Credentials.SessionToken | xargs)
                  fi

                  # Set global settings
                  set_remote_credentials
                  export PUPPETSERVER=$(/usr/local/bin/aws opsworks-cm describe-servers --region=${OCM_REGION} ${AWS_CLI_EXTRA_OPTS[@]:-} --query "Servers[?ServerName=='${OCM_SERVER}'].Endpoint" --output text)
                  unset_remote_credentials
                  export PRUBY='/opt/puppetlabs/puppet/bin/ruby'
                  export PUPPET='/opt/puppetlabs/bin/puppet'
                  export DAEMONSPLAY='true'
                  export SPLAYLIMIT='180'
                  export PUPPET_CA_PATH='/etc/puppetlabs/puppet/ssl/certs/ca.pem'
                  export PUPPET_CRL_PATH='/etc/puppetlabs/puppet/ssl/crl.pem'
                  export AGENT_CATALOG_RUN_LOCK='/opt/puppetlabs/puppet/cache/state/agent_catalog_run.lock'

                  # If we cannot get determine PUPPETSERVER, we stop here and try again later (thanks to the cron job).
                  if [ -z ${PUPPETSERVER} ]; then
                    echo "PUPPETSERVER cannot be determined, exiting"
                    exit 0
                  fi

                  # If we cannot get reach PUPPETSERVER, we stop here and try again later (thanks to the cron job).
                  if ! ping -c 1 ${PUPPETSERVER} &> /dev/null; then
                    echo "'${PUPPETSERVER}' unreachable, exiting"
                    exit 0
                  fi
                }

                function prepare_puppet {
                  LOCK_FILE="/opt/puppetlabs/puppet/cache/state/agent_disabled.lock"

                  # If the agent is disabled, skip this run
                  if [[ -f "${LOCK_FILE}" ]]; then
                    echo "'${LOCK_FILE}' exists, exiting"
                    exit 0
                  fi

                  mkdir -p /opt/puppetlabs/puppet/cache/state
                  mkdir -p /etc/puppetlabs/puppet/ssl/certs/
                  mkdir -p /etc/puppetlabs/code/modules/

                  echo "{\"disabled_message\":\"Locked by OpsWorks Deploy - $(date --iso-8601=seconds)\"}" > "${LOCK_FILE}"
                }

                function establish_trust {
                  # If the cert exists, skip this step
                  if [[ -f "${PUPPET_CA_PATH}" ]]; then
                    echo "'${PUPPET_CA_PATH}' exists, skipping function 'establish_trust'"
                    return 0
                  fi

                  set_remote_credentials
                  /usr/local/bin/aws opsworks-cm describe-servers --region=${OCM_REGION} --server-name ${OCM_SERVER} ${AWS_CLI_EXTRA_OPTS[@]:-} --query "Servers[0].EngineAttributes[?Name=='PUPPET_API_CA_CERT'].Value" --output text > "${PUPPET_CA_PATH}"
                  unset_remote_credentials
                }

                function install_puppet {
                  # If Puppet is installed, skip this step
                  if [[ -f "${PUPPET}" ]]; then
                    echo "Puppet already installed, skipping function 'install_puppet'"
                    return 0
                  fi

                  { # try
                    # Install the Puppet Agent using the scripts provided by the Puppet Master
                    ADD_EXTENSIONS=$(generate_csr_attributes)
                    [[ $? -eq 0 ]] || ADD_EXTENSIONS=''

                    # NOTE: Other than the original script, we are going to use the host name for the certificate to make it more human readable
                    curl --cacert ${PUPPET_CA_PATH} --retry 3 "https://${PUPPETSERVER}:8140/packages/current/install.bash" | \
                      /bin/bash -s agent:certname=$(hostname) \
                        agent:splay=${DAEMONSPLAY} \
                        extension_requests:pp_instance_id=${PP_INSTANCE_ID} \
                        extension_requests:pp_region=${PP_REGION} \
                        extension_requests:pp_image_name=${PP_IMAGE_NAME} ${ADD_EXTENSIONS}
                  } || { # catch
                    if which dnf > /dev/null 2>&1; then
                      # Install the Puppet Agent using a package repository, since RHEL/CentOS 8 are not supported by the PE version provided by AWS (2018.1.7)
                      dnf --assumeyes install https://yum.puppetlabs.com/puppet5/el/8/x86_64/puppet5-release-5.0.0-14.el8.noarch.rpm
                      dnf --assumeyes install puppet-agent
                    else
                      echo "Installation of Puppet failed, exiting"
                      exit 1
                    fi
                  }

                  # Register the Puppet Master
                  ${PUPPET} config set server ${PUPPETSERVER} --section main
                  ${PUPPET} resource service puppet ensure=stopped
                }

                function generate_csr_attributes {
                  pp_tags=$(/usr/local/bin/aws ec2 describe-tags --region ${PP_REGION} --filters "Name=resource-id,Values=${PP_INSTANCE_ID}" --query 'Tags[?starts_with(Key, `pp_`)].[Key,Value]' --output text | sed s/[[:blank:]]/=/)
                  if [ -z ${pp_tags} ]; then
                    echo "Couldn't describe tags (check permissions in the IAM role), skipping function 'generate_csr_attributes'"
                    return 1
                  fi

                  csr_attrs=""
                  for i in $pp_tags; do
                    csr_attrs="${csr_attrs} extension_requests:${i}"
                  done

                  echo ${csr_attrs}
                }

                function install_puppet_bootstrap {
                  ${PUPPET} help bootstrap > /dev/null && bootstrap_installed=true || bootstrap_installed=false
                  if [ "${bootstrap_installed}" = false ]; then
                    echo "Puppet Bootstrap not present, installing"
                    curl --retry 3 https://s3-eu-west-1.amazonaws.com/opsworks-cm-eu-west-1-beta-default-assets/misc/owpe/puppet-agent-bootstrap-0.2.1.tar.gz -o /tmp/puppet-agent-bootstrap-0.2.1.tar.gz
                    ${PUPPET} module install /tmp/puppet-agent-bootstrap-0.2.1.tar.gz --ignore-dependencies
                    rm /tmp/puppet-agent-bootstrap-0.2.1.tar.gz
                    echo "Puppet Bootstrap installed"
                  else
                    echo "Puppet Bootstrap already present"
                  fi
                }

                function associate_node {
                  CERTNAME=$(${PUPPET} config print certname --section agent)
                  SSLDIR=$(${PUPPET} config print ssldir --section agent)
                  PP_CSR_PATH="${SSLDIR}/certificate_requests/${CERTNAME}.pem"
                  PP_CERT_PATH="${SSLDIR}/certs/${CERTNAME}.pem"

                  # If the nodes certificate already exists, skip this step
                  if [[ -f "${PP_CERT_PATH}" ]]; then
                    echo "'${PP_CERT_PATH}' already exists, skipping function 'associate_node'"
                    return 0
                  fi

                  # Workaround for broken bootstrapping on AWS when using short_name in CSR extension_requests
                  # -> https://github.com/puppetlabs/puppet-agent-bootstrap/pull/11
                  CSR_FILE='/etc/puppetlabs/puppet/csr_attributes.yaml'
                  sed -i 's/pp_instance_id/1.3.6.1.4.1.34380.1.1.2/g' ${CSR_FILE}
                  sed -i 's/pp_image_name/1.3.6.1.4.1.34380.1.1.3/g' ${CSR_FILE}
                  sed -i 's/pp_region/1.3.6.1.4.1.34380.1.1.18/g' ${CSR_FILE}
                  # END Workaround

                  # Clear out extraneous certs and generate a new one
                  ${PUPPET} bootstrap purge
                  ${PUPPET} bootstrap csr

                  set_remote_credentials

                  # Workaround for failing automatic certificate download by Puppet, if the Puppet Master is in a different account
                  # Re-download CA certificate
                  /usr/local/bin/aws opsworks-cm describe-servers --region=${OCM_REGION} --server-name ${OCM_SERVER} ${AWS_CLI_EXTRA_OPTS[@]:-} --query "Servers[0].EngineAttributes[?Name=='PUPPET_API_CA_CERT'].Value" --output text > "${PUPPET_CA_PATH}"

                  # Re-download Certificate Revocation List
                  /usr/local/bin/aws opsworks-cm describe-servers --region=${OCM_REGION} --server-name ${OCM_SERVER} ${AWS_CLI_EXTRA_OPTS[@]:-} --query "Servers[0].EngineAttributes[?Name=='PUPPET_API_CRL'].Value" --output text > "${PUPPET_CRL_PATH}"
                  # END Workaround

                  # Submit the cert
                  ASSOCIATE_TOKEN=$(/usr/local/bin/aws opsworks-cm associate-node --region ${OCM_REGION} --server-name ${OCM_SERVER} ${AWS_CLI_EXTRA_OPTS[@]:-} --node-name ${CERTNAME} --engine-attributes Name=PUPPET_NODE_CSR,Value="`cat ${PP_CSR_PATH}`" --query "NodeAssociationStatusToken" --output text)

                  # Wait
                  /usr/local/bin/aws opsworks-cm wait node-associated --region ${OCM_REGION} --node-association-status-token "${ASSOCIATE_TOKEN}" --server-name ${OCM_SERVER} ${AWS_CLI_EXTRA_OPTS[@]:-}

                  # Install and verify
                  /usr/local/bin/aws opsworks-cm describe-node-association-status --region ${OCM_REGION} --node-association-status-token "${ASSOCIATE_TOKEN}" --server-name ${OCM_SERVER} ${AWS_CLI_EXTRA_OPTS[@]:-} --query 'EngineAttributes[0].Value' --output text > ${PP_CERT_PATH}

                  unset_remote_credentials
                }

                function run_puppet {
                  sleep $[ ( ${RANDOM} % ${SPLAYLIMIT} ) + 1]s
                  ${PUPPET} agent --enable

                  sleep $[ ( ${RANDOM} % ${SPLAYLIMIT} ) + 1]s
                  waitfor_puppet_finish
                  ${PUPPET} resource service puppet ensure=running enable=true

                  sleep $[ ( ${RANDOM} % ${SPLAYLIMIT} ) + 1]s
                  waitfor_puppet_finish
                  ${PUPPET} agent --onetime --verbose --no-daemonize --no-usecacheonfailure --no-splay --show_diff

                  sleep $[ ( ${RANDOM} % ${SPLAYLIMIT} ) + 1]s
                  waitfor_puppet_finish
                  ${PUPPET} bootstrap verify
                }

                function waitfor_puppet_finish {
                  local rcnt=10

                  while [ -f ${AGENT_CATALOG_RUN_LOCK} ]; do
                    echo "detected ${AGENT_CATALOG_RUN_LOCK}. Sleeping"
                    sleep 30

                    let rcnt=$rcnt-1
                    if [ $rcnt -eq 0 ]; then
                      echo "Maximal iterations of sleep time reached. Giving up"
                      break
                    fi
                  done
                }

                # Check for existence of the PID file to prevent parallel executions of this script
                if [[ -f "${PID_FILE}" ]]; then
                  echo "'${PID_FILE}' exists, exiting"
                  exit 0
                fi

                # Ensure PID file is removed on program exit.
                trap "rm -f -- '${PID_FILE}'" EXIT

                # Create a file with current PID to indicate that process is running.
                echo $$ > "${PID_FILE}"

                set_aws_settings
                prepare_puppet
                establish_trust
                install_puppet
                install_puppet_bootstrap
                associate_node
                run_puppet

                # If we reach this point, the script ran successfully -> delete the cron file that re-triggers this script
                rm -f /etc/cron.d/bootstrap-puppet-starter
              mode: "000744"
              owner: "root"
              group: "root"

        # Find, format and mount volumes attached to this Instance
        BootstrapVolumes:
          files:
            /opt/aws/init/bootstrap-volumes.sh:
              content: |
                #!/usr/bin/env bash

                # ************************************
                # This file is managed by CloudFormation
                # Do not modify!
                # ************************************

                # **************************************************************************** #
                # Imports and functions                                                        #
                # **************************************************************************** #

                # Get the device name of an EBS Volume attached to a host using NVMe (on those, the predefined device name will be ignored and instead a name calculated by NVMe will be used)
                # See: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html
                #
                # @param String   VOLUME_ID	  The EBS Volume ID (example: 'vol-0218b8b99fe422a1c')
                #
                # @return String  The device name (e.g. '/dev/nvme1n1') of the specified Volume or failure (return code 1)
                function AWS::EC2::getNvmeDeviceName() {
                  local -r VOLUME_ID="${1:-}"; shift;

                  # Parameter validation
                  [[ -z ${VOLUME_ID} ]] && return 1

                  local BlockDevice=$( lsblk --nodeps --noheadings --output NAME,SERIAL | grep "${VOLUME_ID//-}" )

                  # If the result is empty, this can mean either
                  # A: The Volume is not attached to this host (in NVMe systems the Volume ID is used as disk serial number and thus should show up in 'lsblk') or
                  # B: Instance is not using NVMe and thus the device name must have been wrong
                  # In either way, we stop here.
                  [[ -z ${BlockDevice} ]] && return 1

                  # Return the real device name (first element of the 'lsblk' entry)
                  echo "/dev/${BlockDevice%% *}"
                }


                # Formats DEVICE and, if specified, syncs the content of MOUNT_POINT to it.
                #
                # @param String   DEVICE	      The device of the new Volume (example: '/dev/nvme1n1')
                # @param String   FS_TYPE	      The file system of DEVICE (example: 'ext4')
                # @param String   MOUNT_POINT	  Optional: The designated mount point for DEVICE /opt')
                #
                # @return Bool  True when the device was prepared successfully, otherwise false
                function prepareNewVolume() {
                  local -r DEVICE="${1:-}"; shift;
                  local -r FS_TYPE="${1:-}"; shift;
                  local -r MOUNT_POINT="${1:-}"; shift;

                  # Parameter validation
                  [[ ! -b ${DEVICE} ]] && return 1
                  [[ -z ${FS_TYPE} ]] && return 1

                  # Format the device if it is not already formatted with the desired FS:
                  #   if ! file --special-files --dereference ${DEVICE} | grep filesystem || [[ $( lsblk -no FSTYPE ${DEVICE} ) != ${FS_TYPE} ]]; then
                  # Format the device if it is not already formatted at all
                  if ! file --special-files --dereference ${DEVICE} | grep filesystem; then
                    mkfs --type ${FS_TYPE} ${DEVICE} || return 1
                    # It takes a few moments for the UUID to become available after formatting
                    sleep 5
                  fi

                  if [[ -n ${MOUNT_POINT} ]]; then
                    # (re-)add an entry for ${MOUNT_POINT} if a VolumeID has been specified
                    mkdir --parents "${MOUNT_POINT}"

                    # Temporarily mount ${DEVICE} at a tmp folder for data migration
                    local TmpMountPoint=$( mktemp --directory --tmpdir="/mnt" )
                    mount --types "${FS_TYPE}" --source "${DEVICE}" --target "${TmpMountPoint}" || return 1

                    # Sync all data from ${MOUNT_POINT} to prevent data loss
                    rsync --archive --update --one-file-system --xattrs  "${MOUNT_POINT}"/* "${TmpMountPoint}"

                    # Unmount ${DEVICE} from its temporary location and, if successful delete ${TmpMountPoint}
                    umount "${TmpMountPoint}" && rm --recursive --force "${TmpMountPoint}"
                  fi

                  return 0
                }


                # **************************************************************************** #
                # Init                                                                         #
                # **************************************************************************** #

                # The device that should be used for the Volume (example: '/dev/sdh' or 'xvdh') (making sure that it is in the format '/dev/...')
                declare -r Device="/dev/${1#'/dev/'}"; shift;
                # The mount point that should be used for the Volume (example: '/opt')
                declare -r MountPoint=$1; shift;
                # The file system that should be used for the Volume (example: 'ext4')
                declare -r FileSystemType=$1; shift;
                # The EBS Volume ID (example: 'vol-0218b8b99fe422a1c')
                declare -r VolumeID=$1; shift;

                # Parameter validation
                [[ -z ${Device} ]] && exit 1
                [[ -z ${MountPoint} ]] && exit 1
                [[ -z ${FileSystemType} ]] && exit 1


                # **************************************************************************** #
                # Main                                                                         #
                # **************************************************************************** #

                # Delete existing entries for ${MountPoint} in the fstab (to prevent false matches)
                sed --in-place "\@ ${MountPoint} @d" /etc/fstab

                # If no VolumeID has been specified, we assume that it is no longer attached to this instance and thus will stop here (kind of a fail-safe)
                [[ -z ${VolumeID} ]] && exit 0

                # If the device does not exist, this can mean either
                # A: The device name is wrong or
                # B: The Instance is using NVMe (on those, the predefined device name will be ignored and instead a name calculated by NVMe will be used)
                if [[ -e ${Device} ]]; then
                  RealDeviceName="${Device}"
                else
                  RealDeviceName=$( AWS::EC2::getNvmeDeviceName ${VolumeID} ) || exit 1
                fi

                # If the Volume is not already mounted at ${MountPoint}, format it and sync the contents of ${MountPoint} to it (spaces to prevent false matches)
                if ! ( grep --no-messages "${RealDeviceName} " /proc/mounts | grep --no-messages --quiet " ${MountPoint} " ); then
                  prepareNewVolume "${RealDeviceName}" "${FileSystemType}" "${MountPoint}" || exit 1

                  # Signal to a later running script that a reboot is required (and be kind by even leaving a note with who requested it ;) )
                  echo "${BASH_SOURCE[@]} ${Device} ${MountPoint} ${FileSystemType} ${VolumeID}" >> /tmp/.reboot-required
                fi

                # Use UUID to mount the device in the future (device names can change with NVMe)
                UUID=$( lsblk --noheadings --output UUID ${RealDeviceName} ) || exit 1
                echo "UUID=${UUID}    ${MountPoint}    ${FileSystemType}    defaults    0    0" >> /etc/fstab

                exit 0
              mode: "000744"
              owner: "root"
              group: "root"
          commands:
            0100_bootstrap_opt:
              command: !If
                - CreateVolumeOpt
                - !Sub '/opt/aws/init/bootstrap-volumes.sh "${VolumeOptDeviceName}" "/opt" "ext4" "${VolumeOpt}"'
                - !Sub '/opt/aws/init/bootstrap-volumes.sh "${VolumeOptDeviceName}" "/opt" "ext4"'
            0200_bootstrap_tmp:
              command: !If
                - CreateVolumeTmp
                - !Sub '/opt/aws/init/bootstrap-volumes.sh "${VolumeTmpDeviceName}" "/tmp" "ext4" "${VolumeTmp}" && systemctl unmask tmp.mount'
                - !Sub '/opt/aws/init/bootstrap-volumes.sh "${VolumeTmpDeviceName}" "/tmp" "ext4" && systemctl mask tmp.mount'
            0300_bootstrap_var:
              command: !If
                - CreateVolumeVar
                - !Sub '/opt/aws/init/bootstrap-volumes.sh "${VolumeVarDeviceName}" "/var" "ext4" "${VolumeVar}"'
                - !Sub '/opt/aws/init/bootstrap-volumes.sh "${VolumeVarDeviceName}" "/var" "ext4"'

        # Make sure the AWS CLI Tools are present
        # See: https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-linux.html
        EnsureAwsCli:
          sources:
            /opt/aws/awscli-bundle: "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"
          commands:
            0100_install_awscli:
              command: '/opt/aws/awscli-bundle/aws/install --install-dir "/usr/local/aws-cli" --bin-dir "/usr/local/bin"'
            # Fix: __main__.MultipleBundlesError: Multiple versions of the CLI were found in /opt/aws/awscli-bundle/packages. Please clear out this directory before proceeding.
            0200_cleanup:
              command: "rm -rf /opt/aws/awscli-bundle"

        # Make sure the cfn-hup helper that detects changes in resource metadata and runs user-specified actions when a change is detected are present
        # See: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-hup.html
        EnsureCfnHup:
          files:
            /etc/cfn/cfn-hup.conf:
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
              mode: "000400"
              owner: "root"
              group: "root"
            /etc/cfn/hooks.d/cfn-auto-reloader.conf:
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.Instance.Metadata.AWS::CloudFormation::Init
                action=/opt/aws/bin/cfn-init --stack=${AWS::StackName} --resource=Instance --configsets=default,restart-set --region=${AWS::Region}
                runas=root
            /lib/systemd/system/cfn-hup.service:
              content: |
                [Unit]
                Description=cfn-hup daemon

                [Service]
                Type=simple
                ExecStart=/opt/aws/bin/cfn-hup
                Restart=always

                [Install]
                WantedBy=multi-user.target
          commands:
            0100_systemd_enable_cfn_hup:
              test: 'test $(ps --no-headers -o comm 1) == "systemd"'
              command: "systemctl enable cfn-hup.service"
            0200_systemd_start_cfn_hup:
              test: 'test $(ps --no-headers -o comm 1) == "systemd"'
              command: "systemctl start cfn-hup.service"
          services:
            sysvinit:
              cfn-hup:
                enabled: "true"
                ensureRunning: "true"
                files:
                - "/etc/cfn/cfn-hup.conf"
                - "/etc/cfn/hooks.d/cfn-auto-reloader.conf"

        # Is only started in initial run of cfn-init and sets a puppet installer cronjob
        InitializePuppet:
          files:
            # Script to trigger the Puppet Master script in section "BootstrapPuppet" sets up a cronjob that triggers the puppet script install.
            # Necessary workaround due to network delay during the first setup of an ec2-instance
            /etc/cron.d/bootstrap-puppet-starter:
              content: |
                # ************************************
                # This file is managed by CloudFormation
                # Do not modify!
                # ************************************
                SHELL=/bin/bash
                PATH=/sbin:/bin:/usr/sbin:/usr/bin
                MAILTO=root
                */5 * * * * root /opt/aws/init/bootstrap-puppet.sh >> /opt/aws/init/bootstrap-puppet.log 2>&1
              mode: "000644"
              owner: "root"
              group: "root"

        # Reboots the Instance if required by other steps (e.g. BootstrapVolumes)
        OptionalReboot:
          commands:
            0100_reboot:
              test: "test -f /tmp/.reboot-required"
              command: "rm --force /tmp/.reboot-required; reboot"

        # Set the host name to something more verbose
        SetHostname:
          commands:
            0100_sysconfig:
              command: !Sub
                # "Fn::Sub" prevents bash parameter substitution, so we use "sed" instead
                - "HOSTNAME=$(echo ${ActualHostName}-${HostedZoneName} | sed 's/\\./-/g'); echo HOSTNAME=$HOSTNAME >> /etc/sysconfig/network"
                - ActualHostName: !If
                    - HasHostName
                    - !Ref HostName
                    - !Sub "${RootStackName}-${Designation}"
            0200_systemd:
              test: 'test $(ps --no-headers -o comm 1) == "systemd"'
              command: !Sub
                # "Fn::Sub" prevents bash parameter substitution, so we use "sed" instead
                - "HOSTNAME=$(echo ${ActualHostName}-${HostedZoneName} | sed 's/\\./-/g'); hostnamectl set-hostname $HOSTNAME"
                - ActualHostName: !If
                    - HasHostName
                    - !Ref HostName
                    - !Sub "${RootStackName}-${Designation}"

  #=======================================
  # Volumes
  #=======================================

  # The Volume that will be mounted to /opt
  VolumeOpt:
    Condition: CreateVolumeOpt
    Type: AWS::EC2::Volume
    DeletionPolicy: "Delete"
    Properties:
      AvailabilityZone: !Ref AvailabilityZone
      Encrypted: !Ref VolumeOptEncryption
      Iops: !If
        - SetVolumeOptIops
        - !Ref VolumeOptIops
        - !Ref AWS::NoValue
      Size: !Ref VolumeOptSize
      Tags:
      - Key: "Name"
        Value: !Sub "${RootStackName}-volume-${Designation}-opt"
      - !If
        - EnableAutoSnapshot
        - Key: "AutomaticSnapshots"
          Value: !Ref FeatureAutoSnapshot
        - !Ref AWS::NoValue
      Throughput: !If
        - SetVolumeOptThroughput
        - !Ref VolumeOptThroughput
        - !Ref AWS::NoValue
      VolumeType: !Ref VolumeOptType

  # The Volume that will be mounted to /tmp
  VolumeTmp:
    Condition: CreateVolumeTmp
    Type: AWS::EC2::Volume
    DeletionPolicy: "Delete"
    Properties:
      AvailabilityZone: !Ref AvailabilityZone
      Encrypted: !Ref VolumeTmpEncryption
      Iops: !If
        - SetVolumeTmpIops
        - !Ref VolumeTmpIops
        - !Ref AWS::NoValue
      Size: !Ref VolumeTmpSize
      Tags:
      - Key: "Name"
        Value: !Sub "${RootStackName}-volume-${Designation}-tmp"
      - !If
        - EnableAutoSnapshot
        - Key: "AutomaticSnapshots"
          Value: !Ref FeatureAutoSnapshot
        - !Ref AWS::NoValue
      Throughput: !If
        - SetVolumeTmpThroughput
        - !Ref VolumeTmpThroughput
        - !Ref AWS::NoValue
      VolumeType: !Ref VolumeTmpType

  # The Volume that will be mounted to /var
  VolumeVar:
    Condition: CreateVolumeVar
    Type: AWS::EC2::Volume
    DeletionPolicy: "Delete"
    Properties:
      AvailabilityZone: !Ref AvailabilityZone
      Encrypted: !Ref VolumeVarEncryption
      Iops: !If
        - SetVolumeVarIops
        - !Ref VolumeVarIops
        - !Ref AWS::NoValue
      Size: !Ref VolumeVarSize
      Tags:
      - Key: "Name"
        Value: !Sub "${RootStackName}-volume-${Designation}-var"
      - !If
        - EnableAutoSnapshot
        - Key: "AutomaticSnapshots"
          Value: !Ref FeatureAutoSnapshot
        - !Ref AWS::NoValue
      Throughput: !If
        - SetVolumeVarThroughput
        - !Ref VolumeVarThroughput
        - !Ref AWS::NoValue
      VolumeType: !Ref VolumeVarType

  #=======================================
  # Route 53 DNS Records
  #=======================================

  # The optional DNS Record for the instance
  DnsRecords:
    Condition: CreateDnsRecord
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: "../r53/dns-records.yaml"
      Parameters:
        # DNS Record configuration
        #
        DnsName: !If
          - HasHostName
          - !Ref HostName
          - !Sub "${RootStackName}-${Designation}"
        HostedZoneName: !Ref HostedZoneName
        Target: !GetAtt Instance.PrivateIp
        Type: "A"

        # Remote DNS Record configuration (optional)
        #
        ServiceToken: !Ref DnsServiceToken


################################################################################
#
# Outputs (optional)
# Declares output values that you can import into other stacks (to create cross-stack references)
#
# See: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/outputs-section-structure.html
#
################################################################################

Outputs:

  InstanceId:
    Description: "The ID of the created Instance."
    Value: !Ref Instance
